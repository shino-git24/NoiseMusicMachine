<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noise Machine</title>
    <style>
        /* === CSS === */
        body {
            background-color: #111;
            color: #eee;
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0; /* 上下の余白を詰める */
            box-sizing: border-box;
        }
        #noise-machine {
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px 25px; /* 内側の余白を詰める */
            width: 300px;
        }
        h1 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px; /* 下の余白を詰める */
            color: #fff;
            letter-spacing: 2px;
            font-size: 1.8em; /* 文字サイズを少し小さく */
        }
        .control {
            margin-bottom: 12px; /* 各セクションの余白を詰める */
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px; /* ラベル下の余白を詰める */
            font-size: 0.9em;   /* 文字サイズを少し小さく */
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #d9534f;
            color: white;
            transition: background-color 0.2s;
        }
        button.on {
            background-color: #5cb85c;
        }
        /* ★追加: ビジュアライザー(canvas)のスタイル */
        #visualizer {
            background-color: #000;
            border: 1px solid #444;
            width: 100%;
            height: 100px;
            border-radius: 4px;
        }

#filter-type-buttons {
            display: flex;
            justify-content: space-between;
        }
        button.filter-type {
            width: 23%;
            padding: 10px 5px;
            font-size: 0.9em;
            background-color: #555;
        }
        button.filter-type.active {
            background-color: #77aaff;
            color: #111;
        }

/* ノイズ種類ボタンのスタイル */
        #noise-type-buttons {
            display: flex;
            justify-content: space-between;
        }
        button.noise-type {
            width: 32%;
            padding: 10px 5px;
            font-size: 0.9em;
            background-color: #555;
        }
        button.noise-type.active {
            background-color: #a777ff;
            color: #111;
        }

    /* 録音ボタンと結果エリアのスタイル */
        #record-button.recording {
            background-color: #ff4757;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 71, 87, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0); }
        }
        #recording-results audio {
            width: 100%;
            margin-bottom: 10px;
        }
        #recording-results a {
            display: block;
            text-align: center;
            background-color: #555;
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            text-decoration: none;
            transition: background-color 0.2s;
        }
        #recording-results a:hover {
            background-color: #777;
        }    

/* === シーケンサーのスタイル === */
        .step-button {
            width: 100%;
            height: 30px;
            border: 1px solid #777;
            background-color: #444;
            transition: background-color 0.1s;
        }
        .step-button.active {
            background-color: #ff8c00; /* ONの状態 */
        }
        .step-button.playing {
            border-color: #fff;
            box-shadow: 0 0 5px #fff; /* 再生中のステップを光らせる */
        }

        /* === トースト通知のスタイル === */
        #notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #222;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            border: 1px solid #555;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
            pointer-events: none; /* 通知が表示中でも下の要素を操作可能にする */
        }
        #notification.show {
            opacity: 1;
            bottom: 30px;
        }

        /* ★追加: オシレーター種類ボタンのスタイル */
#osc-type-buttons {
    display: flex;
    justify-content: space-between;
}
button.osc-type {
    width: 32%;
    padding: 10px 5px;
    font-size: 0.9em;
    background-color: #555;
}
button.osc-type.active {
    background-color: #77aaff; /* オシレーターがONの時は青系の色にしてみます */
    color: #111;
}

/* ★追加: LFOターゲットボタンのスタイル */
button.lfo-target {
    width: 32%;
    padding: 10px 5px;
    font-size: 0.9em;
    background-color: #555;
    color: white;
    border: none;
    border-radius: 4px; /* 角を少し丸める */
    cursor: pointer;
    transition: background-color 0.2s;
}
button.lfo-target.active {
    background-color: #f0ad4e; /* ターゲット選択中はオレンジ色に */
    color: #111;
    font-weight: bold;
}

/* ★追加: LFOタイプボタンのスタイル */
button.lfo-type {
    width: 32%;
    padding: 10px 5px;
    font-size: 0.9em;
    background-color: #555;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}
button.lfo-type.active {
    background-color: #a777ff; /* 元のnoise-typeなどと同じ紫色に */
    color: #111;
    font-weight: bold;
}

    </style>
</head>
<body>

    <div id="noise-machine">
        <h1>NOISE MACHINE</h1>

                <div class="control" id="preset-section" style="background-color: #222; padding: 10px; border-radius: 5px;">
            <label style="font-size: 1.1em; margin-bottom: 10px;">PRESETS</label>
            <div style="display: flex; gap: 10px;">
                <select id="preset-select" style="flex-grow: 1; background-color: #555; color: white; border: 1px solid #777;"></select>
                <button id="preset-load" class="filter-type">LOAD</button>
                <button id="preset-delete" class="filter-type" style="background-color: #d9534f;">DELETE</button>
            </div>
            <div style="margin-top: 10px;">
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                 <button id="preset-export" style="width: 50%; background-color: #f0ad4e; color: white; border:none; padding: 10px; border-radius: 4px; cursor: pointer;">EXPORT ALL</button>
                 <button id="preset-import" style="width: 50%; background-color: #5bc0de; color: white; border:none; padding: 10px; border-radius: 4px; cursor: pointer;">IMPORT</button>
                 <input type="file" id="preset-file-input" accept=".json" style="display: none;">
            </div>
                <button id="preset-save" style="width: 100%; background-color: #5cb85c; color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">SAVE CURRENT SETTINGS</button>
            </div>
        </div>

    <div class="control">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <label style="margin-bottom: 0;">VISUALIZER</label>
                <button id="visualizer-toggle" class="filter-type active" style="width: auto; padding: 2px 10px; font-size: 0.8em;">ON</button>
            </div>
            <canvas id="visualizer"></canvas>
        </div>

        <div class="control">
            <button id="power-switch">POWER OFF</button>
        </div>

        <div class="control" id="noise-type-section">
            <label>NOISE TYPE</label>
            <div id="noise-type-buttons">
                <button class="noise-type active" data-type="white">WHITE</button>
                <button class="noise-type" data-type="pink">PINK</button>
                <button class="noise-type" data-type="brown">BROWN</button>
            </div>
        </div>

        <div class="control" id="oscillator-section">
            <label>OSCILLATOR</label>
            <button id="osc-power-switch">OSC OFF</button>
            <div id="osc-controls" style="margin-top: 15px; display: none;">
                <label>OSC TYPE</label>
                <div id="osc-type-buttons" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <button class="osc-type active" data-type="sawtooth">SAW</button> <button class="osc-type" data-type="square">SQUARE</button> <button class="osc-type" data-type="triangle">TRIANGLE</button> </div>
                <label for="osc-frequency-slider">FREQUENCY (20-2000Hz)</label>
                <input type="range" id="osc-frequency-slider" min="20" max="2000" value="440" step="1">
                <label for="osc-volume-slider" style="margin-top: 10px;">VOLUME</label>
                <input type="range" id="osc-volume-slider" min="0" max="0.5" value="0" step="0.01">
            </div>
        </div>

        <div class="control">
            <label for="volume-slider">VOLUME</label>
            <input type="range" id="volume-slider" min="0" max="1" value="0.5" step="0.01">
        </div>

        <div class="control" id="envelope-section">
            <label>AMPLITUDE ENVELOPE</label>
            <button id="hit-button" style="padding: 20px; font-size: 1.5em; font-weight: bold; background-color: #ff8c00; color: white; border: none; border-radius: 5px; cursor: pointer;">HIT</button>
            <div style="margin-top: 15px;">
                <label for="attack-slider">ATTACK</label>
                <input type="range" id="attack-slider" min="0.01" max="2" value="0.01" step="0.01">
                <label for="decay-slider" style="margin-top: 10px;">DECAY</label>
                <input type="range" id="decay-slider" min="0.01" max="3" value="1" step="0.01">
            </div>
            <div style="margin-top: 20px; border-top: 1px solid #555; padding-top: 15px;">
                <label for="pitch-start-slider">PITCH START (Hz): <span id="pitch-start-display">880</span></label>
<input type="range" id="pitch-start-slider" min="100" max="2000" value="880" step="10">
                <label for="pitch-end-slider" style="margin-top: 10px;">PITCH END (Hz)</label>
                <input type="range" id="pitch-end-slider" min="20" max="500" value="50" step="5">
                <label for="pitch-decay-slider" style="margin-top: 10px;">PITCH DECAY (s)</label>
                <input type="range" id="pitch-decay-slider" min="0.01" max="1" value="0.1" step="0.01">
            </div>
        </div>

        <div class="control" id="filter-section">
            <label>FILTER TYPE</label>
            <div id="filter-type-buttons">
                <button class="filter-type active" data-type="lowpass">LPF</button>
                <button class="filter-type" data-type="highpass">HPF</button>
                <button class="filter-type" data-type="bandpass">BPF</button>
                <button class="filter-type" data-type="notch">NOTCH</button>
            </div>
        </div>

        <div class="control">
            <label for="frequency-slider">FREQUENCY</label>
            <input type="range" id="frequency-slider" min="20" max="20000" value="20000" step="1">
        </div>


        <div class="control">
            <label for="q-slider">RESONANCE (Q)</label>
            <input type="range" id="q-slider" min="0.1" max="30" value="1" step="0.1">

        </div>

    <div class="control" id="lfo-section">
            <label>LFO (LOW FREQUENCY OSCILLATOR)</label>
            <div style="margin-top: 10px;">
                <label>TARGET</label>
                <div id="lfo-target-buttons" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <button class="lfo-target active" data-target="none">OFF</button>
                    <button class="lfo-target" data-target="filterFrequency">FILTER FREQ</button>
                    <button class="lfo-target" data-target="oscFrequency">OSC FREQ</button>
                </div>
                <label for="lfo-rate-slider">RATE (0.1 - 20 Hz)</label>
                <input type="range" id="lfo-rate-slider" min="0.1" max="20" value="5" step="0.1">
                <label for="lfo-depth-slider" style="margin-top: 10px;">DEPTH</label>
                <input type="range" id="lfo-depth-slider" min="0" max="5000" value="0" step="1">
                <label style="margin-top: 10px;">LFO TYPE</label>
                <div id="lfo-type-buttons" style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <button class="lfo-type active" data-type="sine">SINE</button>
                    <button class="lfo-type" data-type="square">SQUARE</button>
                    <button class="lfo-type" data-type="sawtooth">SAW</button>
                </div>
            </div>
        </div>

        <div class="control">
            <label for="feedback-slider">FEEDBACK</label>
            <input type="range" id="feedback-slider" min="0" max="0.99" value="0" step="0.01">
        </div>

        <div class="control">
            <label for="distortion-slider">DISTORTION</label>
            <input type="range" id="distortion-slider" min="0" max="1000" value="0" step="1">
        </div>

        <div class="control">
            <button id="record-button">RECORD</button>
        </div>
        <div id="recording-results">
        </div>
        <div class="control" id="sequencer-section" style="background-color: #222; padding: 10px; border-radius: 5px;">
            <label style="font-size: 1.1em; margin-bottom: 10px;">STEP SEQUENCER</label>
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                <button id="sequencer-start-stop" style="padding: 10px 20px; font-weight: bold; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">START</button>
                <div style="flex-grow: 1;">
                    <label for="bpm-slider" style="margin-bottom: 5px;">BPM: <span id="bpm-display">120</span></label>
                    <input type="range" id="bpm-slider" min="40" max="240" value="120" step="1">
                </div>
            </div>
            <div id="step-grid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; row-gap: 10px;">
                <button class="step-button" data-step="0"></button>
                <button class="step-button" data-step="1"></button>
                <button class="step-button" data-step="2"></button>
                <button class="step-button" data-step="3"></button>
                <button class="step-button" data-step="4"></button>
                <button class="step-button" data-step="5"></button>
                <button class="step-button" data-step="6"></button>
                <button class="step-button" data-step="7"></button>
                <button class="step-button" data-step="8"></button>
                <button class="step-button" data-step="9"></button>
                <button class="step-button" data-step="10"></button>
                <button class="step-button" data-step="11"></button>
                <button class="step-button" data-step="12"></button>
                <button class="step-button" data-step="13"></button>
                <button class="step-button" data-step="14"></button>
                <button class="step-button" data-step="15"></button>
            </div>
        </div>
    </div>

<script>
    // === JavaScript (Web Audio API) ===

    let audioContext, whiteNoiseNode, driveNode, distortionNode, filterNode, feedbackGainNode, delayNode, gainNode, limiterNode, analyserNode,
    oscillatorNode, oscillatorGainNode,
    lfoNode, lfoDepthNode,
    envelopeGainNode; // ★ エンベロープ用のGainNodeを追加
    let noiseBuffers = {};
    let currentNoiseType = 'white';
    let mediaRecorder, recorderDestinationNode, recordedChunks = [];
    let isRecording = false;
    let isOscOn = false;
    let currentLfoTarget = 'none';

    let isPowerOn = false;
    let isVisualizerOn = true; // ビジュアライザーのON/OFF状態
    let animationFrameId;

    const powerSwitch = document.getElementById('power-switch');
    const volumeSlider = document.getElementById('volume-slider');
    const distortionSlider = document.getElementById('distortion-slider');
    const visualizerCanvas = document.getElementById('visualizer');
    const canvasCtx = visualizerCanvas.getContext('2d');

    powerSwitch.addEventListener('click', () => {
        if (!isPowerOn) {
            if (!audioContext) { setupAudio(); }
            audioContext.resume();
            isPowerOn = true;
            powerSwitch.textContent = 'POWER ON';
            powerSwitch.classList.add('on');
            // ビジュアライザーがON設定の時だけ描画を開始する
            if (isVisualizerOn) {
                drawWaveform();
            }
        } else {
            audioContext.suspend();
            isPowerOn = false;
            powerSwitch.textContent = 'POWER OFF';
            powerSwitch.classList.remove('on');
            cancelAnimationFrame(animationFrameId);
        }
    });

    volumeSlider.addEventListener('input', (event) => {
        if (gainNode) { gainNode.gain.value = parseFloat(event.target.value); }
    });

    // ★★★ ドライブ機能を完全に復活させた最終バージョン ★★★
    distortionSlider.addEventListener('input', (event) => {
        if (distortionNode && driveNode) {
            const amount = parseInt(event.target.value);
            
            // ドライブ（入力ゲイン）をスライダーと連動させる
            const driveValue = 1 + (amount / 1000) * 49;
            driveNode.gain.value = driveValue; 

            // 歪みのカーブを更新する
            distortionNode.curve = makeDistortionCurve(amount);
        }
    });

// ★★★ フィルターコントロールのイベントリスナー ★★★
    const frequencySlider = document.getElementById('frequency-slider');
    const qSlider = document.getElementById('q-slider');
    const filterButtons = document.querySelectorAll('.filter-type');

    frequencySlider.addEventListener('input', (event) => {
        if (filterNode) { 
            // 周波数は対数的な変化が自然なので、スライダーの値を変換して使う
            const minLog = Math.log(20);
            const maxLog = Math.log(20000);
            // スライダーの位置を0-1の範囲に正規化
            const range = maxLog - minLog;
            const logValue = parseFloat(event.target.value) / 20000;
            // 対数スケールに変換
            const freq = Math.exp(minLog + range * (parseFloat(event.target.value) / 20000));
            // filterNode.frequency.value = parseFloat(event.target.value); 
             filterNode.frequency.setTargetAtTime(parseFloat(event.target.value), audioContext.currentTime, 0.01);
        }
    });

    qSlider.addEventListener('input', (event) => {
        if (filterNode) { filterNode.Q.value = parseFloat(event.target.value); }
    });
    
    filterButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (filterNode) {
                // すべてのボタンから .active クラスを削除
                filterButtons.forEach(btn => btn.classList.remove('active'));
                // クリックされたボタンに .active クラスを追加
                button.classList.add('active');
                // フィルターのタイプを更新
                filterNode.type = button.dataset.type;
            }
        });
    });

    // ★★★ フィードバックコントロールのイベントリスナー ★★★
    const feedbackSlider = document.getElementById('feedback-slider');
    feedbackSlider.addEventListener('input', (event) => {
        if (feedbackGainNode) {
            feedbackGainNode.gain.value = parseFloat(event.target.value);
        }
    });

// ★★★ ノイズ種類切り替えのイベントリスナー ★★★
    const noiseButtons = document.querySelectorAll('.noise-type');
    noiseButtons.forEach(button => {
        button.addEventListener('click', () => {
            const newType = button.dataset.type;
            if (currentNoiseType === newType || !isPowerOn) return; // 同じタイプか電源OFFなら何もしない

            currentNoiseType = newType;

            // ボタンの見た目を更新
            noiseButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            // ノイズの再生を入れ替える
            whiteNoiseNode.stop(); // 古いノイズを停止
            whiteNoiseNode = audioContext.createBufferSource(); // 新しいソースを作成
            whiteNoiseNode.buffer = noiseBuffers[currentNoiseType]; // 新しいバッファを設定
            whiteNoiseNode.loop = true;
            whiteNoiseNode.connect(driveNode); // ドライブに接続
            whiteNoiseNode.start(); // 新しいノイズを再生
        });
    });

    // ★★★ 種類の違うノイズを生成する専門の関数 ★★★
    function createNoiseBuffer(type) {
        const bufferSize = audioContext.sampleRate * 2; // 2秒間のバッファ
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        let i;

        if (type === 'white') {
            for (i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
        } else if (type === 'pink') {
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                data[i] *= 0.11; // ゲイン調整
                b6 = white * 0.115926;
            }
        } else if (type === 'brown') {
            let lastOut = 0.0;
            for (i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; // ゲイン調整
            }
        }
        
        return buffer;
    }

function setupAudio() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        noiseBuffers.white = createNoiseBuffer('white');
        noiseBuffers.pink = createNoiseBuffer('pink');
        noiseBuffers.brown = createNoiseBuffer('brown');
        
        whiteNoiseNode = audioContext.createBufferSource();
        whiteNoiseNode.buffer = noiseBuffers[currentNoiseType];
        whiteNoiseNode.loop = true;

        driveNode = audioContext.createGain();
        driveNode.gain.value = 1;

        distortionNode = audioContext.createWaveShaper();
        distortionNode.oversample = '4x';
        distortionNode.curve = makeDistortionCurve(parseInt(distortionSlider.value));

        filterNode = audioContext.createBiquadFilter();
        filterNode.type = 'lowpass';
        filterNode.frequency.value = parseFloat(document.getElementById('frequency-slider').value);
        filterNode.Q.value = parseFloat(document.getElementById('q-slider').value);

        feedbackGainNode = audioContext.createGain();
        feedbackGainNode.gain.value = parseFloat(document.getElementById('feedback-slider').value);

        delayNode = audioContext.createDelay();
        delayNode.delayTime.value = 0.01;

        limiterNode = audioContext.createDynamicsCompressor();
        limiterNode.threshold.value = -3.0;
        limiterNode.knee.value = 0.0;
        limiterNode.ratio.value = 20.0;
        limiterNode.attack.value = 0.005;
        limiterNode.release.value = 0.05;

        gainNode = audioContext.createGain();
        gainNode.gain.value = parseFloat(volumeSlider.value);

        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;

        recorderDestinationNode = audioContext.createMediaStreamDestination();

        oscillatorNode = audioContext.createOscillator();
        oscillatorNode.type = 'sawtooth';
        oscillatorNode.frequency.value = 440;
        
        oscillatorGainNode = audioContext.createGain();
        oscillatorGainNode.gain.value = 0;

        lfoNode = audioContext.createOscillator();
        lfoNode.type = 'sine';
        lfoNode.frequency.value = 5;

        lfoDepthNode = audioContext.createGain();
        lfoDepthNode.gain.value = 0;

        lfoNode.connect(lfoDepthNode);

        // --- ノードの接続 ---
        whiteNoiseNode.connect(driveNode);
        oscillatorNode.connect(oscillatorGainNode);
        oscillatorGainNode.connect(driveNode);

        driveNode.connect(distortionNode);
        distortionNode.connect(filterNode);
        filterNode.connect(gainNode);
        
        gainNode.connect(limiterNode);
        
        limiterNode.connect(analyserNode);
        analyserNode.connect(audioContext.destination);
        limiterNode.connect(recorderDestinationNode);

        filterNode.connect(feedbackGainNode);
        feedbackGainNode.connect(delayNode);
        delayNode.connect(driveNode);

        whiteNoiseNode.start();
        oscillatorNode.start();
        lfoNode.start();
    }
    
    function drawWaveform() {
        const bufferLength = analyserNode.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyserNode.getByteTimeDomainData(dataArray);
        canvasCtx.fillStyle = '#000000';
        canvasCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = '#00ff00';
        canvasCtx.beginPath();
        const sliceWidth = visualizerCanvas.width * 1.0 / bufferLength;
        let x = 0;
        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * visualizerCanvas.height / 2;
            if (i === 0) { canvasCtx.moveTo(x, y); } else { canvasCtx.lineTo(x, y); }
            x += sliceWidth;
        }
        canvasCtx.lineTo(visualizerCanvas.width, visualizerCanvas.height / 2);
        canvasCtx.stroke();

        // 自身を再度呼び出すことでループを継続する
        animationFrameId = requestAnimationFrame(drawWaveform);
    }

    // ★★★ 歪みの方式をtanh関数に戻す ★★★
    function makeDistortionCurve(amount) {
        if (amount === 0) { return null; }
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        
        // amountをkという名前にして、歪みの強さとして使う
        const k = amount / 10; // 少し調整して変化を滑らかに

        for (let i = 0; i < n_samples; ++i) {
            const x = i * 2 / n_samples - 1;
            // tanh関数を使って波形を変形させる
            curve[i] = Math.tanh(x * k);
        }
        return curve;
    }

// ★★★ オシレーターコントロールのイベントリスナー ★★★
    const oscPowerSwitch = document.getElementById('osc-power-switch');
    const oscControls = document.getElementById('osc-controls');
    const oscTypeButtons = document.querySelectorAll('.osc-type');
    const oscFrequencySlider = document.getElementById('osc-frequency-slider');
    const oscVolumeSlider = document.getElementById('osc-volume-slider');

    oscPowerSwitch.addEventListener('click', () => {
        // メイン電源がONの時だけ動作
        if (!isPowerOn) return;

        isOscOn = !isOscOn;
        if (isOscOn) {
            oscPowerSwitch.textContent = 'OSC ON';
            oscPowerSwitch.classList.add('on'); // メイン電源と同じスタイルを適用
            oscControls.style.display = 'block';
            // ONにした瞬間のボリュームをスライダーの値に設定
            oscillatorGainNode.gain.setTargetAtTime(parseFloat(oscVolumeSlider.value), audioContext.currentTime, 0.01);
        } else {
            oscPowerSwitch.textContent = 'OSC OFF';
            oscPowerSwitch.classList.remove('on');
            oscControls.style.display = 'none';
            // OFFにしたら音量を0にする
            oscillatorGainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.01);
        }
    });

    // オシレーター波形タイプの切り替え
    oscTypeButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (oscillatorNode && isOscOn) {
                oscTypeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                oscillatorNode.type = button.dataset.type;
            }
        });
    });

    // オシレーター周波数の変更
    oscFrequencySlider.addEventListener('input', (e) => {
        if (oscillatorNode) {
            oscillatorNode.frequency.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
        }
    });

    // オシレーター音量の変更
    oscVolumeSlider.addEventListener('input', (e) => {
        // オシレーターがONの時だけボリューム変更を適用
        if (oscillatorNode && isOscOn) {
            oscillatorGainNode.gain.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
        }
    });

    // ★★★ LFOコントロールのイベントリスナー ★★★
    const lfoRateSlider = document.getElementById('lfo-rate-slider');
    const lfoDepthSlider = document.getElementById('lfo-depth-slider');
    const lfoTypeButtons = document.querySelectorAll('.lfo-type');
    const lfoTargetButtons = document.querySelectorAll('.lfo-target');

    // LFOの速さ(Rate)を変更
    lfoRateSlider.addEventListener('input', (e) => {
        if (lfoNode) {
            lfoNode.frequency.value = parseFloat(e.target.value);
        }
    });

    // LFOの深さ(Depth)を変更
    lfoDepthSlider.addEventListener('input', (e) => {
        if (lfoDepthNode) {
            lfoDepthNode.gain.value = parseFloat(e.target.value);
        }
    });

    // LFOの波形タイプを変更
    lfoTypeButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (lfoNode) {
                lfoTypeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                lfoNode.type = button.dataset.type;
            }
        });
    });

    // LFOのターゲットを変更
    lfoTargetButtons.forEach(button => {
        button.addEventListener('click', () => {
            // メイン電源が入っていない場合は何もしない
            if (!isPowerOn || !lfoDepthNode) return;

            // まず、すべての接続を解除
            lfoDepthNode.disconnect();

            // ターゲットボタンの見た目を更新
            lfoTargetButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            const newTarget = button.dataset.target;
            currentLfoTarget = newTarget;

            // ターゲットに応じて接続先を切り替え
            if (newTarget === 'filterFrequency') {
                lfoDepthNode.connect(filterNode.frequency);
                lfoDepthSlider.max = 5000; // Depthスライダーの最大値を調整
            } else if (newTarget === 'oscFrequency') {
                lfoDepthNode.connect(oscillatorNode.frequency);
                lfoDepthSlider.max = 1000; // Depthスライダーの最大値を調整
            } else {
                // 'none' の場合はDepthを0にしておく
                lfoDepthSlider.value = 0;
                lfoDepthNode.gain.value = 0;
            }
        });
    });

// ★★★ ビジュアライザーON/OFFのイベントリスナー ★★★
    const visualizerToggle = document.getElementById('visualizer-toggle');

    visualizerToggle.addEventListener('click', () => {
        isVisualizerOn = !isVisualizerOn;

        if (isVisualizerOn) {
            visualizerToggle.textContent = 'ON';
            visualizerToggle.classList.add('active');
            // 描画開始はメイン電源がONの時だけ
            if (isPowerOn) {
                drawWaveform();
            }
        } else {
            visualizerToggle.textContent = 'OFF';
            visualizerToggle.classList.remove('active');
            // 描画停止と画面クリアは、電源の状態に関係なく実行する
            cancelAnimationFrame(animationFrameId);
            setTimeout(() => {
                canvasCtx.fillStyle = '#000000';
                canvasCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            }, 50);
        }
    });

    // ★★★ 録音機能のロジック ★★★
    const recordButton = document.getElementById('record-button');
    const resultsArea = document.getElementById('recording-results');

    recordButton.addEventListener('click', () => {
        if (!isPowerOn) return; // 電源が入っていないと録音しない

        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    });

    function startRecording() {
        isRecording = true;
        recordedChunks = []; // チャンクをリセット
        resultsArea.innerHTML = ''; // 前回の結果をクリア

        const options = { mimeType: 'audio/webm' };
        try {
            mediaRecorder = new MediaRecorder(recorderDestinationNode.stream, options);
        } catch (e) {
            console.error('Error creating MediaRecorder:', e);
            isRecording = false;
            return;
        }


        mediaRecorder.addEventListener('dataavailable', (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        });

            mediaRecorder.addEventListener('stop', () => {
            // ★ Blobのタイプとファイル名を .wav に変更
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);

            const audio = document.createElement('audio');
            audio.controls = true;
            audio.src = url;
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            const now = new Date();
            const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            downloadLink.download = `noise-recording-${timestamp}.webm`;
            downloadLink.innerText = 'Download Recording';

            resultsArea.appendChild(audio);
            resultsArea.appendChild(downloadLink);
        });

        mediaRecorder.start();
        recordButton.textContent = 'STOP RECORDING';
        recordButton.classList.add('recording');
    }

    function stopRecording() {
        if (mediaRecorder) {
            mediaRecorder.stop();
        }
        isRecording = false;
        recordButton.textContent = 'RECORD';
        recordButton.classList.remove('recording');
    }
    
    // ★★★ HITボタンのイベントリスナー (ピッチ調整機能付き) ★★★
    const hitButton = document.getElementById('hit-button');
    const attackSlider = document.getElementById('attack-slider');
    const decaySlider = document.getElementById('decay-slider');
    const pitchStartSlider = document.getElementById('pitch-start-slider');
    const pitchEndSlider = document.getElementById('pitch-end-slider');
    const pitchDecaySlider = document.getElementById('pitch-decay-slider');

    hitButton.addEventListener('click', () => {
        if (!isPowerOn || !audioContext) return;

        const now = audioContext.currentTime;
        const masterVolume = parseFloat(volumeSlider.value);

        const hitOsc = audioContext.createOscillator();
        hitOsc.type = 'sine';

        const hitEnvelope = audioContext.createGain();

        hitOsc.connect(hitEnvelope);
        hitEnvelope.connect(limiterNode);

        // 4. 音程の変化（ピッチエンベロープ）をスライダーの値から設定する
        const pitchStart = parseFloat(pitchStartSlider.value);
        const pitchEnd = parseFloat(pitchEndSlider.value);
        const pitchDecay = parseFloat(pitchDecaySlider.value);

        hitOsc.frequency.setValueAtTime(pitchStart, now);
        hitOsc.frequency.exponentialRampToValueAtTime(pitchEnd, now + pitchDecay);

        // 5. 音量の変化（アンプエンベロープ）を設定する
        const attackTime = parseFloat(attackSlider.value);
        const decayTime = parseFloat(decaySlider.value);
        hitEnvelope.gain.cancelScheduledValues(now);
        hitEnvelope.gain.setValueAtTime(0, now);
        hitEnvelope.gain.linearRampToValueAtTime(masterVolume, now + attackTime);
        hitEnvelope.gain.linearRampToValueAtTime(0, now + attackTime + decayTime);

        // 6. 発音をスケジュールする
        hitOsc.start(now);
        const stopTime = Math.max(pitchDecay, attackTime + decayTime) + 0.1; // ピッチと音量のエンベロープが長い方に合わせる
        hitOsc.stop(now + stopTime);
    });

    // ★★★ プリセット機能のロジック ★★★
    const presetSelect = document.getElementById('preset-select');
    const presetLoadBtn = document.getElementById('preset-load');
    const presetSaveBtn = document.getElementById('preset-save');
    const presetDeleteBtn = document.getElementById('preset-delete');
    const PRESET_STORAGE_KEY = 'noiseMachinePresets';

    // --- 1. 保存されているプリセットを読み込んでドロップダウンを更新する関数 ---
    function updatePresetList() {
        const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || [];
        presetSelect.innerHTML = ''; // ドロップダウンを一旦空にする

        presets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.name;
            option.textContent = preset.name;
            presetSelect.appendChild(option);
        });
    }



    // --- 3. ページ読み込み時に一度リストを更新する ---
    updatePresetList();

    // ★★★ プリセット機能のロジック（LOAD & DELETE） ★★★

    // --- 4. プリセットを適用する中心的な関数 ---
    function applyPreset(settings) {
        if (!settings) return;

        // --- スライダーの値をUIとWeb Audio APIの両方に適用 ---
        const updateSlider = (sliderId, value, audioNode, paramName) => {
            const slider = document.getElementById(sliderId);
            if (slider) slider.value = value;
            if (audioNode) {
                // 'gain' や 'frequency' など、AudioParamオブジェクトのプロパティに値を設定
                if (audioNode[paramName]) {
                    audioNode[paramName].value = parseFloat(value);
                } else {
                    audioNode.value = parseFloat(value);
                }
            }
        };
        
        updateSlider('volume-slider', settings.volume, gainNode.gain);
        updateSlider('frequency-slider', settings.frequency, filterNode.frequency);
        updateSlider('q-slider', settings.resonance, filterNode.Q);
        updateSlider('feedback-slider', settings.feedback, feedbackGainNode.gain);
        updateSlider('distortion-slider', settings.distortion, null); // Distortionは特殊なので後で
        updateSlider('osc-frequency-slider', settings.oscFreq, oscillatorNode.frequency);
        updateSlider('osc-volume-slider', settings.oscVol, oscillatorGainNode.gain);
        updateSlider('lfo-rate-slider', settings.lfoRate, lfoNode.frequency);
        updateSlider('lfo-depth-slider', settings.lfoDepth, lfoDepthNode.gain);
        updateSlider('attack-slider', settings.attack, null);
        updateSlider('decay-slider', settings.decay, null);
        
        // Distortionスライダーの特殊処理
        const distortionSliderEl = document.getElementById('distortion-slider');
        if(distortionSliderEl) {
            distortionSliderEl.value = settings.distortion;
            // 既存のイベントリスナーを発火させてドライブとカーブを更新するのが最も確実
            distortionSliderEl.dispatchEvent(new Event('input'));
        }


        // --- ボタンが押されたかのように振る舞わせ、UIと処理を同時に更新 ---
        const updateButtons = (selector, savedType) => {
            if (!savedType) return;
            document.querySelectorAll(selector).forEach(btn => {
                if (btn.dataset.type === savedType) {
                    if (!btn.classList.contains('active')) btn.click();
                } else {
                    if (btn.classList.contains('active')) btn.click(); // NOTE: この方法は単純なトグルには不向きな場合がある
                }
            });
        };
        
        // NOTE: 上記のupdateButtonsは理想的ではないため、より確実な方法に変更します。
        const clickButton = (selector, savedType) => {
             if (!savedType) return;
             const targetButton = document.querySelector(`${selector}[data-type="${savedType}"]`);
             if (targetButton && !targetButton.classList.contains('active')) {
                 targetButton.click();
             }
        };
        
        clickButton('.noise-type', settings.noiseType);
        clickButton('.filter-type', settings.filterType);
        clickButton('.osc-type', settings.oscType);
        clickButton('.lfo-target', settings.lfoTarget);
        clickButton('.lfo-type', settings.lfoType);

        // ON/OFFスイッチの処理
        const oscSwitch = document.getElementById('osc-power-switch');
        if (oscSwitch && oscSwitch.classList.contains('on') !== settings.oscOn) {
            oscSwitch.click();
        }
    }

// --- 5. 「LOAD」ボタンが押された時の処理 ---
    presetLoadBtn.addEventListener('click', () => {
        const presetName = presetSelect.value;
        if (!presetName) {
            showNotification('読み込むプリセットが選択されていません。');
            return;
        }

        const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || [];
        const preset = presets.find(p => p.name === presetName);

        if (preset) {
            applyPreset(preset.values);
            showNotification(`「${presetName}」を読み込みました。`);
        } else {
            showNotification('エラー：プリセットが見つかりません。');
        }
    });

// --- 6. 「DELETE」ボタンが押された時の処理 ---
    presetDeleteBtn.addEventListener('click', () => {
        const presetName = presetSelect.value;
        if (!presetName) {
            showNotification('削除するプリセットが選択されていません。');
            return;
        }

        if (confirm(`本当に「${presetName}」を削除しますか？この操作は元に戻せません。`)) {
            let presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || [];
            presets = presets.filter(p => p.name !== presetName);
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
            updatePresetList(); // リストを更新
            showNotification(`「${presetName}」を削除しました。`);
        }
    });

// ★★★ プリセット機能のロジック（EXPORT） ★★★
    const presetExportBtn = document.getElementById('preset-export');

presetExportBtn.addEventListener('click', () => {
        const presetsJSON = localStorage.getItem(PRESET_STORAGE_KEY);
        const presets = JSON.parse(presetsJSON) || [];

        if (presets.length === 0) {
            showNotification('書き出すプリセットがありません。');
            return;
        }

        const blob = new Blob([presetsJSON], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `noise-machine-presets-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });

// ★★★ プリセット機能のロジック（IMPORT） ★★★
    const presetImportBtn = document.getElementById('preset-import');
    const presetFileInput = document.getElementById('preset-file-input');

    // 1. 「IMPORT」ボタンが押されたら、隠れているファイル選択ダイアログを開く
    presetImportBtn.addEventListener('click', () => {
        presetFileInput.click(); // ファイル入力をプログラム的にクリック
    });

 // 2. ファイルが選択された時の処理
    presetFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();

        reader.onload = (e) => {
            try {
                const importedPresets = JSON.parse(e.target.result);
                if (!Array.isArray(importedPresets)) {
                    throw new Error('プリセットファイルは期待された形式ではありません。');
                }
                let currentPresets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || [];
                let importedCount = 0;
                let overwrittenCount = 0;
                importedPresets.forEach(importedPreset => {
                    if (importedPreset && importedPreset.name && importedPreset.values) {
                        const existingIndex = currentPresets.findIndex(p => p.name === importedPreset.name);
                        if (existingIndex > -1) {
                            currentPresets[existingIndex] = importedPreset;
                            overwrittenCount++;
                        } else {
                            currentPresets.push(importedPreset);
                            importedCount++;
                        }
                    }
                });
                localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(currentPresets));
                updatePresetList();
                showNotification(`${importedCount}個のプリセットを新しく追加し、${overwrittenCount}個のプリセットを上書きしました。`);
            } catch (error) {
                showNotification('ファイルの読み込みに失敗しました。有効なプリセットファイルではありません。');
            } finally {
                event.target.value = '';
            }
        };
        reader.readAsText(file);
    });

    // ★★★ スライダーの数値を表示する機能 ★★★
    //const pitchStartSlider = document.getElementById('pitch-start-slider');
    const pitchStartDisplay = document.getElementById('pitch-start-display');

    pitchStartSlider.addEventListener('input', (event) => {
    pitchStartDisplay.textContent = event.target.value;
    });

    // ★★★ シーケンサー機能のロジック ★★★
    const startStopBtn = document.getElementById('sequencer-start-stop');
    const bpmSlider = document.getElementById('bpm-slider');
    const bpmDisplay = document.getElementById('bpm-display');
    const stepButtons = document.querySelectorAll('.step-button');

    let isSequencerPlaying = false;
    let currentStep = 0;
    let bpm = 120;
    let sequencerIntervalId = null;

    // --- ステップボタンのON/OFFを切り替える処理 ---
    stepButtons.forEach(button => {
        button.addEventListener('click', () => {
            button.classList.toggle('active');
        });
    });

    // --- BPMスライダーを動かした時の処理 ---
    bpmSlider.addEventListener('input', (event) => {
        bpm = parseInt(event.target.value);
        bpmDisplay.textContent = bpm;
        // もし再生中なら、一度止めて新しいテンポで再開する
        if (isSequencerPlaying) {
            stopSequencer();
            startSequencer();
        }
    });

// --- シーケンサーのメインループ ---
    function sequencerLoop() {
        // 1. 前のステップのハイライトを消す
        const prevStep = (currentStep === 0) ? 15 : currentStep - 1;
        stepButtons[prevStep].classList.remove('playing');

        // 2. 現在のステップのボタンを取得し、ハイライトする
        const currentStepButton = stepButtons[currentStep];
        currentStepButton.classList.add('playing');

        // 3. 現在のステップがON（activeクラスを持つ）なら、音を鳴らす
        if (currentStepButton.classList.contains('active')) {
            // HITボタンのクリック処理をプログラム的に呼び出す
            hitButton.click();
        }

        // 4. 次のステップへ
        currentStep = (currentStep + 1) % 16;
    }

    // --- シーケンサーを開始する関数 ---
    function startSequencer() {
        // 1分あたりの拍数(BPM)から、16分音符1つあたりの時間を計算 (ミリ秒)
        const stepTime = 60000 / bpm / 4;
        
        sequencerIntervalId = setInterval(sequencerLoop, stepTime);
        startStopBtn.textContent = 'STOP';
        startStopBtn.style.backgroundColor = '#d9534f'; // 赤色に変更
        isSequencerPlaying = true;
    }

    // --- シーケンサーを停止する関数 ---
    function stopSequencer() {
        clearInterval(sequencerIntervalId);
        sequencerIntervalId = null;
        startStopBtn.textContent = 'START';
        startStopBtn.style.backgroundColor = '#4CAF50'; // 緑色に戻す
        isSequencerPlaying = false;
        currentStep = 0; // 停止したらステップをリセット

        // ★追加: 全てのステップのハイライトを消す
        stepButtons.forEach(button => button.classList.remove('playing'));
    }

// --- START/STOPボタンが押された時の処理 ---
    startStopBtn.addEventListener('click', () => {
        if (isSequencerPlaying) {
            stopSequencer();
        } else {
            // 電源がONの時だけシーケンサーを開始
            if (isPowerOn) {
                startSequencer();
            } else {
                showNotification('まず本体のPOWERをONにしてください。');
            }
        }
    });

    // ★★★ 新しい通知機能 ★★★

function showNotification(message) {
        const notification = document.getElementById('notification');
        if (!notification) return; // もし要素がなければ何もしない

        // 以前のタイマーが残っていればクリア
        if (notification.timeoutId) {
            clearTimeout(notification.timeoutId);
        }

        notification.textContent = message;
        notification.classList.add('show');

        // 2秒後に通知を消すタイマーを設定
        notification.timeoutId = setTimeout(() => {
            notification.classList.remove('show');
        }, 2000);
    }

    // --- 「SAVE」ボタンのイベントリスナーを上書き ---
    presetSaveBtn.addEventListener('click', () => {
        const presetName = prompt('プリセット名を入力してください：', 'My Awesome Noise');
        if (!presetName) return;
        const settings = { noiseType: document.querySelector('.noise-type.active')?.dataset.type, volume: document.getElementById('volume-slider').value, oscOn: document.getElementById('osc-power-switch').classList.contains('on'), oscType: document.querySelector('.osc-type.active')?.dataset.type, oscFreq: document.getElementById('osc-frequency-slider').value, oscVol: document.getElementById('osc-volume-slider').value, filterType: document.querySelector('.filter-type.active')?.dataset.type, frequency: document.getElementById('frequency-slider').value, resonance: document.getElementById('q-slider').value, lfoTarget: document.querySelector('.lfo-target.active')?.dataset.type, lfoRate: document.getElementById('lfo-rate-slider').value, lfoDepth: document.getElementById('lfo-depth-slider').value, lfoType: document.querySelector('.lfo-type.active')?.dataset.type, feedback: document.getElementById('feedback-slider').value, distortion: document.getElementById('distortion-slider').value, attack: document.getElementById('attack-slider').value, decay: document.getElementById('decay-slider').value,pitchStart: document.getElementById('pitch-start-slider').value,
    pitchEnd: document.getElementById('pitch-end-slider').value,
    pitchDecay: document.getElementById('pitch-decay-slider').value };
        console.log(JSON.stringify(settings, null, 2)); // ★追加: 設定オブジェクトをコンソールに見やすく表示
        const newPreset = { name: presetName, values: settings };
        const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || [];
        const existingIndex = presets.findIndex(p => p.name === presetName);
        if (existingIndex > -1) {
            if (confirm(`「${presetName}」は既に存在します。上書きしますか？`)) {
                presets[existingIndex] = newPreset;
            } else {
                return;
            }
        } else {
            presets.push(newPreset);
        }
        localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
        updatePresetList();
        presetSelect.value = presetName;
        showNotification(`「${presetName}」を保存しました！`); // alertを置き換え
    });

    // --- 「LOAD」ボタンのイベントリスナーを上書き ---
    presetLoadBtn.addEventListener('click', () => {
        const presetName = presetSelect.value;
        if (!presetName) {
            showNotification('読み込むプリセットが選択されていません。'); // alertを置き換え
            return;
        }
        const presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || [];
        const preset = presets.find(p => p.name === presetName);
        if (preset) {
            applyPreset(preset.values);
            showNotification(`「${presetName}」を読み込みました。`); // alertを置き換え
        } else {
            showNotification('エラー：プリセットが見つかりません。'); // alertを置き換え
        }
    });

    // --- 「DELETE」ボタンのイベントリスナーを上書き ---
    presetDeleteBtn.addEventListener('click', () => {
        const presetName = presetSelect.value;
        if (!presetName) {
            showNotification('削除するプリセットが選択されていません。'); // alertを置き換え
            return;
        }
        if (confirm(`本当に「${presetName}」を削除しますか？この操作は元に戻せません。`)) {
            let presets = JSON.parse(localStorage.getItem(PRESET_STORAGE_KEY)) || [];
            presets = presets.filter(p => p.name !== presetName);
            localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
            updatePresetList();
            showNotification(`「${presetName}」を削除しました。`); // alertを置き換え
        }
    });

</script>
<div id="notification"></div>
</body>
</html>
