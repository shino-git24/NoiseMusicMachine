<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noise Machine</title>
    <style>
        /* === CSS === */
        body {
            background-color: #111;
            color: #eee;
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        #noise-machine {
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 20px 30px;
            width: 300px;
        }
        h1 {
            text-align: center;
            margin-top: 0;
            color: #fff;
            letter-spacing: 2px;
        }
        .control {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 8px;
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #d9534f;
            color: white;
            transition: background-color 0.2s;
        }
        button.on {
            background-color: #5cb85c;
        }
        /* ★追加: ビジュアライザー(canvas)のスタイル */
        #visualizer {
            background-color: #000;
            border: 1px solid #444;
            width: 100%;
            height: 100px;
            border-radius: 4px;
        }

#filter-type-buttons {
            display: flex;
            justify-content: space-between;
        }
        button.filter-type {
            width: 23%;
            padding: 10px 5px;
            font-size: 0.9em;
            background-color: #555;
        }
        button.filter-type.active {
            background-color: #77aaff;
            color: #111;
        }

/* ノイズ種類ボタンのスタイル */
        #noise-type-buttons {
            display: flex;
            justify-content: space-between;
        }
        button.noise-type {
            width: 32%;
            padding: 10px 5px;
            font-size: 0.9em;
            background-color: #555;
        }
        button.noise-type.active {
            background-color: #a777ff;
            color: #111;
        }

    /* 録音ボタンと結果エリアのスタイル */
        #record-button.recording {
            background-color: #ff4757;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 71, 87, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0); }
        }
        #recording-results audio {
            width: 100%;
            margin-bottom: 10px;
        }
        #recording-results a {
            display: block;
            text-align: center;
            background-color: #555;
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            text-decoration: none;
            transition: background-color 0.2s;
        }
        #recording-results a:hover {
            background-color: #777;
        }    

    </style>
</head>
<body>

    <div id="noise-machine">
        <h1>NOISE MACHINE</h1>

        <div class="control">
            <canvas id="visualizer"></canvas>
        </div>

        <div class="control">
            <button id="power-switch">POWER OFF</button>
        </div>

        <div class="control" id="noise-type-section">
            <label>NOISE TYPE</label>
            <div id="noise-type-buttons">
                <button class="noise-type active" data-type="white">WHITE</button>
                <button class="noise-type" data-type="pink">PINK</button>
                <button class="noise-type" data-type="brown">BROWN</button>
            </div>
        </div>

        <div class="control">
            <label for="volume-slider">VOLUME</label>
            <input type="range" id="volume-slider" min="0" max="1" value="0.5" step="0.01">
        </div>

        <div class="control" id="filter-section">
            <label>FILTER TYPE</label>
            <div id="filter-type-buttons">
                <button class="filter-type active" data-type="lowpass">LPF</button>
                <button class="filter-type" data-type="highpass">HPF</button>
                <button class="filter-type" data-type="bandpass">BPF</button>
                <button class="filter-type" data-type="notch">NOTCH</button>
            </div>
        </div>

        <div class="control">
            <label for="frequency-slider">FREQUENCY</label>
            <input type="range" id="frequency-slider" min="20" max="20000" value="20000" step="1">
        </div>


        <div class="control">
            <label for="q-slider">RESONANCE (Q)</label>
            <input type="range" id="q-slider" min="0.1" max="30" value="1" step="0.1">

        </div>

        <div class="control">
            <label for="feedback-slider">FEEDBACK</label>
            <input type="range" id="feedback-slider" min="0" max="0.99" value="0" step="0.01">
        </div>

        <div class="control">
            <label for="distortion-slider">DISTORTION</label>
            <input type="range" id="distortion-slider" min="0" max="1000" value="0" step="1">
        </div>

        <div class="control">
            <button id="record-button">RECORD</button>
        </div>
        <div id="recording-results">
        </div>
    </div>

<script>
    // === JavaScript (Web Audio API) ===

    let audioContext, whiteNoiseNode, driveNode, distortionNode, filterNode, feedbackGainNode, delayNode, gainNode, limiterNode, analyserNode;
    let noiseBuffers = {};
    let currentNoiseType = 'white';
    let mediaRecorder, recorderDestinationNode, recordedChunks = [];
    let isRecording = false;

    let isPowerOn = false;
    let animationFrameId;

    const powerSwitch = document.getElementById('power-switch');
    const volumeSlider = document.getElementById('volume-slider');
    const distortionSlider = document.getElementById('distortion-slider');
    const visualizerCanvas = document.getElementById('visualizer');
    const canvasCtx = visualizerCanvas.getContext('2d');

    powerSwitch.addEventListener('click', () => {
        if (!isPowerOn) {
            if (!audioContext) { setupAudio(); }
            audioContext.resume();
            isPowerOn = true;
            powerSwitch.textContent = 'POWER ON';
            powerSwitch.classList.add('on');
            drawWaveform();
        } else {
            audioContext.suspend();
            isPowerOn = false;
            powerSwitch.textContent = 'POWER OFF';
            powerSwitch.classList.remove('on');
            cancelAnimationFrame(animationFrameId);
        }
    });

    volumeSlider.addEventListener('input', (event) => {
        if (gainNode) { gainNode.gain.value = parseFloat(event.target.value); }
    });

    // ★★★ ドライブ機能を完全に復活させた最終バージョン ★★★
    distortionSlider.addEventListener('input', (event) => {
        if (distortionNode && driveNode) {
            const amount = parseInt(event.target.value);
            
            // ドライブ（入力ゲイン）をスライダーと連動させる
            const driveValue = 1 + (amount / 1000) * 49;
            driveNode.gain.value = driveValue; 

            // 歪みのカーブを更新する
            distortionNode.curve = makeDistortionCurve(amount);
        }
    });

// ★★★ フィルターコントロールのイベントリスナー ★★★
    const frequencySlider = document.getElementById('frequency-slider');
    const qSlider = document.getElementById('q-slider');
    const filterButtons = document.querySelectorAll('.filter-type');

    frequencySlider.addEventListener('input', (event) => {
        if (filterNode) { 
            // 周波数は対数的な変化が自然なので、スライダーの値を変換して使う
            const minLog = Math.log(20);
            const maxLog = Math.log(20000);
            // スライダーの位置を0-1の範囲に正規化
            const range = maxLog - minLog;
            const logValue = parseFloat(event.target.value) / 20000;
            // 対数スケールに変換
            const freq = Math.exp(minLog + range * (parseFloat(event.target.value) / 20000));
            // filterNode.frequency.value = parseFloat(event.target.value); 
             filterNode.frequency.setTargetAtTime(parseFloat(event.target.value), audioContext.currentTime, 0.01);
        }
    });

    qSlider.addEventListener('input', (event) => {
        if (filterNode) { filterNode.Q.value = parseFloat(event.target.value); }
    });
    
    filterButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (filterNode) {
                // すべてのボタンから .active クラスを削除
                filterButtons.forEach(btn => btn.classList.remove('active'));
                // クリックされたボタンに .active クラスを追加
                button.classList.add('active');
                // フィルターのタイプを更新
                filterNode.type = button.dataset.type;
            }
        });
    });

    // ★★★ フィードバックコントロールのイベントリスナー ★★★
    const feedbackSlider = document.getElementById('feedback-slider');
    feedbackSlider.addEventListener('input', (event) => {
        if (feedbackGainNode) {
            feedbackGainNode.gain.value = parseFloat(event.target.value);
        }
    });

// ★★★ ノイズ種類切り替えのイベントリスナー ★★★
    const noiseButtons = document.querySelectorAll('.noise-type');
    noiseButtons.forEach(button => {
        button.addEventListener('click', () => {
            const newType = button.dataset.type;
            if (currentNoiseType === newType || !isPowerOn) return; // 同じタイプか電源OFFなら何もしない

            currentNoiseType = newType;

            // ボタンの見た目を更新
            noiseButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            // ノイズの再生を入れ替える
            whiteNoiseNode.stop(); // 古いノイズを停止
            whiteNoiseNode = audioContext.createBufferSource(); // 新しいソースを作成
            whiteNoiseNode.buffer = noiseBuffers[currentNoiseType]; // 新しいバッファを設定
            whiteNoiseNode.loop = true;
            whiteNoiseNode.connect(driveNode); // ドライブに接続
            whiteNoiseNode.start(); // 新しいノイズを再生
        });
    });

    // ★★★ 種類の違うノイズを生成する専門の関数 ★★★
    function createNoiseBuffer(type) {
        const bufferSize = audioContext.sampleRate * 2; // 2秒間のバッファ
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        let i;

        if (type === 'white') {
            for (i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
        } else if (type === 'pink') {
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                data[i] *= 0.11; // ゲイン調整
                b6 = white * 0.115926;
            }
        } else if (type === 'brown') {
            let lastOut = 0.0;
            for (i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; // ゲイン調整
            }
        }
        
        return buffer;
    }

    function setupAudio() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        noiseBuffers.white = createNoiseBuffer('white');
        noiseBuffers.pink = createNoiseBuffer('pink');
        noiseBuffers.brown = createNoiseBuffer('brown');
        
        whiteNoiseNode = audioContext.createBufferSource();
        whiteNoiseNode.buffer = noiseBuffers[currentNoiseType];
        whiteNoiseNode.loop = true;

        driveNode = audioContext.createGain();
        driveNode.gain.value = 1;

        distortionNode = audioContext.createWaveShaper();
        distortionNode.oversample = '4x';
        distortionNode.curve = makeDistortionCurve(parseInt(distortionSlider.value));

        filterNode = audioContext.createBiquadFilter();
        filterNode.type = 'lowpass';
        filterNode.frequency.value = parseFloat(document.getElementById('frequency-slider').value);
        filterNode.Q.value = parseFloat(document.getElementById('q-slider').value);

        feedbackGainNode = audioContext.createGain();
        feedbackGainNode.gain.value = parseFloat(document.getElementById('feedback-slider').value);

        delayNode = audioContext.createDelay();
        delayNode.delayTime.value = 0.01;

        limiterNode = audioContext.createDynamicsCompressor();
        limiterNode.threshold.value = -3.0;
        limiterNode.knee.value = 0.0;
        limiterNode.ratio.value = 20.0;
        limiterNode.attack.value = 0.005;
        limiterNode.release.value = 0.05;

        gainNode = audioContext.createGain();
        gainNode.gain.value = parseFloat(volumeSlider.value);

        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;

        // 録音用の出力先ノードを作成
        recorderDestinationNode = audioContext.createMediaStreamDestination();

        // --- ノードの接続 ---
        whiteNoiseNode.connect(driveNode);
        driveNode.connect(distortionNode);
        distortionNode.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(limiterNode);
        
        // リミッターからの出力をスピーカーと録音先の両方に分岐させる
        limiterNode.connect(analyserNode); // スピーカーへの経路
        analyserNode.connect(audioContext.destination);
        limiterNode.connect(recorderDestinationNode); // 録音機への経路

        filterNode.connect(feedbackGainNode);
        feedbackGainNode.connect(delayNode);
        delayNode.connect(driveNode);

        whiteNoiseNode.start();
    }
    
    function drawWaveform() {
        animationFrameId = requestAnimationFrame(drawWaveform);
        const bufferLength = analyserNode.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyserNode.getByteTimeDomainData(dataArray);
        canvasCtx.fillStyle = '#000000';
        canvasCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = '#00ff00';
        canvasCtx.beginPath();
        const sliceWidth = visualizerCanvas.width * 1.0 / bufferLength;
        let x = 0;
        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * visualizerCanvas.height / 2;
            if (i === 0) { canvasCtx.moveTo(x, y); } else { canvasCtx.lineTo(x, y); }
            x += sliceWidth;
        }
        canvasCtx.lineTo(visualizerCanvas.width, visualizerCanvas.height / 2);
        canvasCtx.stroke();
    }

    // ★★★ 歪みの方式をtanh関数に戻す ★★★
    function makeDistortionCurve(amount) {
        if (amount === 0) { return null; }
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        
        // amountをkという名前にして、歪みの強さとして使う
        const k = amount / 10; // 少し調整して変化を滑らかに

        for (let i = 0; i < n_samples; ++i) {
            const x = i * 2 / n_samples - 1;
            // tanh関数を使って波形を変形させる
            curve[i] = Math.tanh(x * k);
        }
        return curve;
    }

    // ★★★ 録音機能のロジック ★★★
    const recordButton = document.getElementById('record-button');
    const resultsArea = document.getElementById('recording-results');

    recordButton.addEventListener('click', () => {
        if (!isPowerOn) return; // 電源が入っていないと録音しない

        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    });

    function startRecording() {
        isRecording = true;
        recordedChunks = []; // チャンクをリセット
        resultsArea.innerHTML = ''; // 前回の結果をクリア

        const options = { mimeType: 'audio/webm' };
        try {
            mediaRecorder = new MediaRecorder(recorderDestinationNode.stream, options);
        } catch (e) {
            console.error('Error creating MediaRecorder:', e);
            isRecording = false;
            return;
        }


        mediaRecorder.addEventListener('dataavailable', (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        });

            mediaRecorder.addEventListener('stop', () => {
            // ★ Blobのタイプとファイル名を .wav に変更
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);

            const audio = document.createElement('audio');
            audio.controls = true;
            audio.src = url;
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            const now = new Date();
            const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            downloadLink.download = `noise-recording-${timestamp}.webm`;
            downloadLink.innerText = 'Download Recording';

            resultsArea.appendChild(audio);
            resultsArea.appendChild(downloadLink);
        });

        mediaRecorder.start();
        recordButton.textContent = 'STOP RECORDING';
        recordButton.classList.add('recording');
    }

    function stopRecording() {
        if (mediaRecorder) {
            mediaRecorder.stop();
        }
        isRecording = false;
        recordButton.textContent = 'RECORD';
        recordButton.classList.remove('recording');
    }

</script>

</body>
</html>
