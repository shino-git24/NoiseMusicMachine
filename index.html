<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noise Machine</title>
    <style>
        /* === CSS === */
        body {
            background-color: #111;
            color: #eee;
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0; /* 上下の余白を詰める */
            box-sizing: border-box;
        }
        #noise-machine {
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px 25px; /* 内側の余白を詰める */
            width: 300px;
        }
        h1 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px; /* 下の余白を詰める */
            color: #fff;
            letter-spacing: 2px;
            font-size: 1.8em; /* 文字サイズを少し小さく */
        }
        .control {
            margin-bottom: 12px; /* 各セクションの余白を詰める */
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px; /* ラベル下の余白を詰める */
            font-size: 0.9em;   /* 文字サイズを少し小さく */
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #d9534f;
            color: white;
            transition: background-color 0.2s;
        }
        button.on {
            background-color: #5cb85c;
        }
        /* ★追加: ビジュアライザー(canvas)のスタイル */
        #visualizer {
            background-color: #000;
            border: 1px solid #444;
            width: 100%;
            height: 100px;
            border-radius: 4px;
        }

#filter-type-buttons {
            display: flex;
            justify-content: space-between;
        }
        button.filter-type {
            width: 23%;
            padding: 10px 5px;
            font-size: 0.9em;
            background-color: #555;
        }
        button.filter-type.active {
            background-color: #77aaff;
            color: #111;
        }

/* ノイズ種類ボタンのスタイル */
        #noise-type-buttons {
            display: flex;
            justify-content: space-between;
        }
        button.noise-type {
            width: 32%;
            padding: 10px 5px;
            font-size: 0.9em;
            background-color: #555;
        }
        button.noise-type.active {
            background-color: #a777ff;
            color: #111;
        }

    /* 録音ボタンと結果エリアのスタイル */
        #record-button.recording {
            background-color: #ff4757;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 71, 87, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0); }
        }
        #recording-results audio {
            width: 100%;
            margin-bottom: 10px;
        }
        #recording-results a {
            display: block;
            text-align: center;
            background-color: #555;
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            text-decoration: none;
            transition: background-color 0.2s;
        }
        #recording-results a:hover {
            background-color: #777;
        }    

    </style>
</head>
<body>

    <div id="noise-machine">
        <h1>NOISE MACHINE</h1>

    <div class="control">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <label style="margin-bottom: 0;">VISUALIZER</label>
                <button id="visualizer-toggle" class="filter-type active" style="width: auto; padding: 2px 10px; font-size: 0.8em;">ON</button>
            </div>
            <canvas id="visualizer"></canvas>
        </div>

        <div class="control">
            <button id="power-switch">POWER OFF</button>
        </div>

        <div class="control" id="noise-type-section">
            <label>NOISE TYPE</label>
            <div id="noise-type-buttons">
                <button class="noise-type active" data-type="white">WHITE</button>
                <button class="noise-type" data-type="pink">PINK</button>
                <button class="noise-type" data-type="brown">BROWN</button>
            </div>
        </div>

        <div class="control" id="oscillator-section">
            <label>OSCILLATOR</label>
            <button id="osc-power-switch">OSC OFF</button>
            <div id="osc-controls" style="margin-top: 15px; display: none;">
                <label>OSC TYPE</label>
                <div id="osc-type-buttons" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <button class="osc-type noise-type active" data-type="sawtooth">SAW</button>
                    <button class="osc-type noise-type" data-type="square">SQUARE</button>
                    <button class="osc-type noise-type" data-type="triangle">TRIANGLE</button>
                </div>
                <label for="osc-frequency-slider">FREQUENCY (20-2000Hz)</label>
                <input type="range" id="osc-frequency-slider" min="20" max="2000" value="440" step="1">
                <label for="osc-volume-slider" style="margin-top: 10px;">VOLUME</label>
                <input type="range" id="osc-volume-slider" min="0" max="0.5" value="0" step="0.01">
            </div>
        </div>

        <div class="control">
            <label for="volume-slider">VOLUME</label>
            <input type="range" id="volume-slider" min="0" max="1" value="0.5" step="0.01">
        </div>

        <div class="control" id="envelope-section">
            <label>AMPLITUDE ENVELOPE</label>
            <button id="hit-button" style="padding: 20px; font-size: 1.5em; font-weight: bold; background-color: #ff8c00; color: white; border: none; border-radius: 5px; cursor: pointer;">HIT</button>
            <div style="margin-top: 15px;">
                <label for="attack-slider">ATTACK</label>
                <input type="range" id="attack-slider" min="0.01" max="2" value="0.01" step="0.01">
                <label for="decay-slider" style="margin-top: 10px;">DECAY</label>
                <input type="range" id="decay-slider" min="0.01" max="3" value="1" step="0.01">
            </div>
        </div>

        <div class="control" id="filter-section">
            <label>FILTER TYPE</label>
            <div id="filter-type-buttons">
                <button class="filter-type active" data-type="lowpass">LPF</button>
                <button class="filter-type" data-type="highpass">HPF</button>
                <button class="filter-type" data-type="bandpass">BPF</button>
                <button class="filter-type" data-type="notch">NOTCH</button>
            </div>
        </div>

        <div class="control">
            <label for="frequency-slider">FREQUENCY</label>
            <input type="range" id="frequency-slider" min="20" max="20000" value="20000" step="1">
        </div>


        <div class="control">
            <label for="q-slider">RESONANCE (Q)</label>
            <input type="range" id="q-slider" min="0.1" max="30" value="1" step="0.1">

        </div>

    <div class="control" id="lfo-section">
            <label>LFO (LOW FREQUENCY OSCILLATOR)</label>
            <div style="margin-top: 10px;">
                <label>TARGET</label>
                <div id="lfo-target-buttons" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <button class="lfo-target filter-type active" data-target="none">OFF</button>
                    <button class="lfo-target filter-type" data-target="filterFrequency">FILTER FREQ</button>
                    <button class="lfo-target filter-type" data-target="oscFrequency">OSC FREQ</button>
                </div>
                <label for="lfo-rate-slider">RATE (0.1 - 20 Hz)</label>
                <input type="range" id="lfo-rate-slider" min="0.1" max="20" value="5" step="0.1">
                <label for="lfo-depth-slider" style="margin-top: 10px;">DEPTH</label>
                <input type="range" id="lfo-depth-slider" min="0" max="5000" value="0" step="1">
                <label style="margin-top: 10px;">LFO TYPE</label>
                <div id="lfo-type-buttons" style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <button class="lfo-type noise-type active" data-type="sine">SINE</button>
                    <button class="lfo-type noise-type" data-type="square">SQUARE</button>
                    <button class="lfo-type noise-type" data-type="sawtooth">SAW</button>
                </div>
            </div>
        </div>

        <div class="control">
            <label for="feedback-slider">FEEDBACK</label>
            <input type="range" id="feedback-slider" min="0" max="0.99" value="0" step="0.01">
        </div>

        <div class="control">
            <label for="distortion-slider">DISTORTION</label>
            <input type="range" id="distortion-slider" min="0" max="1000" value="0" step="1">
        </div>

        <div class="control">
            <button id="record-button">RECORD</button>
        </div>
        <div id="recording-results">
        </div>
    </div>

<script>
    // === JavaScript (Web Audio API) ===

    let audioContext, whiteNoiseNode, driveNode, distortionNode, filterNode, feedbackGainNode, delayNode, gainNode, limiterNode, analyserNode,
    oscillatorNode, oscillatorGainNode,
    lfoNode, lfoDepthNode,
    envelopeGainNode; // ★ エンベロープ用のGainNodeを追加
    let noiseBuffers = {};
    let currentNoiseType = 'white';
    let mediaRecorder, recorderDestinationNode, recordedChunks = [];
    let isRecording = false;
    let isOscOn = false;
    let currentLfoTarget = 'none';

    let isPowerOn = false;
    let isVisualizerOn = true; // ビジュアライザーのON/OFF状態
    let animationFrameId;

    const powerSwitch = document.getElementById('power-switch');
    const volumeSlider = document.getElementById('volume-slider');
    const distortionSlider = document.getElementById('distortion-slider');
    const visualizerCanvas = document.getElementById('visualizer');
    const canvasCtx = visualizerCanvas.getContext('2d');

    powerSwitch.addEventListener('click', () => {
        if (!isPowerOn) {
            if (!audioContext) { setupAudio(); }
            audioContext.resume();
            isPowerOn = true;
            powerSwitch.textContent = 'POWER ON';
            powerSwitch.classList.add('on');
            // ビジュアライザーがON設定の時だけ描画を開始する
            if (isVisualizerOn) {
                drawWaveform();
            }
        } else {
            audioContext.suspend();
            isPowerOn = false;
            powerSwitch.textContent = 'POWER OFF';
            powerSwitch.classList.remove('on');
            cancelAnimationFrame(animationFrameId);
        }
    });

    volumeSlider.addEventListener('input', (event) => {
        if (gainNode) { gainNode.gain.value = parseFloat(event.target.value); }
    });

    // ★★★ ドライブ機能を完全に復活させた最終バージョン ★★★
    distortionSlider.addEventListener('input', (event) => {
        if (distortionNode && driveNode) {
            const amount = parseInt(event.target.value);
            
            // ドライブ（入力ゲイン）をスライダーと連動させる
            const driveValue = 1 + (amount / 1000) * 49;
            driveNode.gain.value = driveValue; 

            // 歪みのカーブを更新する
            distortionNode.curve = makeDistortionCurve(amount);
        }
    });

// ★★★ フィルターコントロールのイベントリスナー ★★★
    const frequencySlider = document.getElementById('frequency-slider');
    const qSlider = document.getElementById('q-slider');
    const filterButtons = document.querySelectorAll('.filter-type');

    frequencySlider.addEventListener('input', (event) => {
        if (filterNode) { 
            // 周波数は対数的な変化が自然なので、スライダーの値を変換して使う
            const minLog = Math.log(20);
            const maxLog = Math.log(20000);
            // スライダーの位置を0-1の範囲に正規化
            const range = maxLog - minLog;
            const logValue = parseFloat(event.target.value) / 20000;
            // 対数スケールに変換
            const freq = Math.exp(minLog + range * (parseFloat(event.target.value) / 20000));
            // filterNode.frequency.value = parseFloat(event.target.value); 
             filterNode.frequency.setTargetAtTime(parseFloat(event.target.value), audioContext.currentTime, 0.01);
        }
    });

    qSlider.addEventListener('input', (event) => {
        if (filterNode) { filterNode.Q.value = parseFloat(event.target.value); }
    });
    
    filterButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (filterNode) {
                // すべてのボタンから .active クラスを削除
                filterButtons.forEach(btn => btn.classList.remove('active'));
                // クリックされたボタンに .active クラスを追加
                button.classList.add('active');
                // フィルターのタイプを更新
                filterNode.type = button.dataset.type;
            }
        });
    });

    // ★★★ フィードバックコントロールのイベントリスナー ★★★
    const feedbackSlider = document.getElementById('feedback-slider');
    feedbackSlider.addEventListener('input', (event) => {
        if (feedbackGainNode) {
            feedbackGainNode.gain.value = parseFloat(event.target.value);
        }
    });

// ★★★ ノイズ種類切り替えのイベントリスナー ★★★
    const noiseButtons = document.querySelectorAll('.noise-type');
    noiseButtons.forEach(button => {
        button.addEventListener('click', () => {
            const newType = button.dataset.type;
            if (currentNoiseType === newType || !isPowerOn) return; // 同じタイプか電源OFFなら何もしない

            currentNoiseType = newType;

            // ボタンの見た目を更新
            noiseButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            // ノイズの再生を入れ替える
            whiteNoiseNode.stop(); // 古いノイズを停止
            whiteNoiseNode = audioContext.createBufferSource(); // 新しいソースを作成
            whiteNoiseNode.buffer = noiseBuffers[currentNoiseType]; // 新しいバッファを設定
            whiteNoiseNode.loop = true;
            whiteNoiseNode.connect(driveNode); // ドライブに接続
            whiteNoiseNode.start(); // 新しいノイズを再生
        });
    });

    // ★★★ 種類の違うノイズを生成する専門の関数 ★★★
    function createNoiseBuffer(type) {
        const bufferSize = audioContext.sampleRate * 2; // 2秒間のバッファ
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        let i;

        if (type === 'white') {
            for (i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
        } else if (type === 'pink') {
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                data[i] *= 0.11; // ゲイン調整
                b6 = white * 0.115926;
            }
        } else if (type === 'brown') {
            let lastOut = 0.0;
            for (i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; // ゲイン調整
            }
        }
        
        return buffer;
    }

function setupAudio() {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        noiseBuffers.white = createNoiseBuffer('white');
        noiseBuffers.pink = createNoiseBuffer('pink');
        noiseBuffers.brown = createNoiseBuffer('brown');
        
        whiteNoiseNode = audioContext.createBufferSource();
        whiteNoiseNode.buffer = noiseBuffers[currentNoiseType];
        whiteNoiseNode.loop = true;

        driveNode = audioContext.createGain();
        driveNode.gain.value = 1;

        distortionNode = audioContext.createWaveShaper();
        distortionNode.oversample = '4x';
        distortionNode.curve = makeDistortionCurve(parseInt(distortionSlider.value));

        filterNode = audioContext.createBiquadFilter();
        filterNode.type = 'lowpass';
        filterNode.frequency.value = parseFloat(document.getElementById('frequency-slider').value);
        filterNode.Q.value = parseFloat(document.getElementById('q-slider').value);

        feedbackGainNode = audioContext.createGain();
        feedbackGainNode.gain.value = parseFloat(document.getElementById('feedback-slider').value);

        delayNode = audioContext.createDelay();
        delayNode.delayTime.value = 0.01;

        limiterNode = audioContext.createDynamicsCompressor();
        limiterNode.threshold.value = -3.0;
        limiterNode.knee.value = 0.0;
        limiterNode.ratio.value = 20.0;
        limiterNode.attack.value = 0.005;
        limiterNode.release.value = 0.05;

        gainNode = audioContext.createGain();
        gainNode.gain.value = parseFloat(volumeSlider.value);

        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;

        recorderDestinationNode = audioContext.createMediaStreamDestination();

        oscillatorNode = audioContext.createOscillator();
        oscillatorNode.type = 'sawtooth';
        oscillatorNode.frequency.value = 440;
        
        oscillatorGainNode = audioContext.createGain();
        oscillatorGainNode.gain.value = 0;

        lfoNode = audioContext.createOscillator();
        lfoNode.type = 'sine';
        lfoNode.frequency.value = 5;

        lfoDepthNode = audioContext.createGain();
        lfoDepthNode.gain.value = 0;

        lfoNode.connect(lfoDepthNode);

        // --- ノードの接続 ---
        whiteNoiseNode.connect(driveNode);
        oscillatorNode.connect(oscillatorGainNode);
        oscillatorGainNode.connect(driveNode);

        driveNode.connect(distortionNode);
        distortionNode.connect(filterNode);
        filterNode.connect(gainNode);
        
        gainNode.connect(limiterNode);
        
        limiterNode.connect(analyserNode);
        analyserNode.connect(audioContext.destination);
        limiterNode.connect(recorderDestinationNode);

        filterNode.connect(feedbackGainNode);
        feedbackGainNode.connect(delayNode);
        delayNode.connect(driveNode);

        whiteNoiseNode.start();
        oscillatorNode.start();
        lfoNode.start();
    }
    
    function drawWaveform() {
        const bufferLength = analyserNode.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyserNode.getByteTimeDomainData(dataArray);
        canvasCtx.fillStyle = '#000000';
        canvasCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = '#00ff00';
        canvasCtx.beginPath();
        const sliceWidth = visualizerCanvas.width * 1.0 / bufferLength;
        let x = 0;
        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * visualizerCanvas.height / 2;
            if (i === 0) { canvasCtx.moveTo(x, y); } else { canvasCtx.lineTo(x, y); }
            x += sliceWidth;
        }
        canvasCtx.lineTo(visualizerCanvas.width, visualizerCanvas.height / 2);
        canvasCtx.stroke();

        // 自身を再度呼び出すことでループを継続する
        animationFrameId = requestAnimationFrame(drawWaveform);
    }

    // ★★★ 歪みの方式をtanh関数に戻す ★★★
    function makeDistortionCurve(amount) {
        if (amount === 0) { return null; }
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        
        // amountをkという名前にして、歪みの強さとして使う
        const k = amount / 10; // 少し調整して変化を滑らかに

        for (let i = 0; i < n_samples; ++i) {
            const x = i * 2 / n_samples - 1;
            // tanh関数を使って波形を変形させる
            curve[i] = Math.tanh(x * k);
        }
        return curve;
    }

// ★★★ オシレーターコントロールのイベントリスナー ★★★
    const oscPowerSwitch = document.getElementById('osc-power-switch');
    const oscControls = document.getElementById('osc-controls');
    const oscTypeButtons = document.querySelectorAll('.osc-type');
    const oscFrequencySlider = document.getElementById('osc-frequency-slider');
    const oscVolumeSlider = document.getElementById('osc-volume-slider');

    oscPowerSwitch.addEventListener('click', () => {
        // メイン電源がONの時だけ動作
        if (!isPowerOn) return;

        isOscOn = !isOscOn;
        if (isOscOn) {
            oscPowerSwitch.textContent = 'OSC ON';
            oscPowerSwitch.classList.add('on'); // メイン電源と同じスタイルを適用
            oscControls.style.display = 'block';
            // ONにした瞬間のボリュームをスライダーの値に設定
            oscillatorGainNode.gain.setTargetAtTime(parseFloat(oscVolumeSlider.value), audioContext.currentTime, 0.01);
        } else {
            oscPowerSwitch.textContent = 'OSC OFF';
            oscPowerSwitch.classList.remove('on');
            oscControls.style.display = 'none';
            // OFFにしたら音量を0にする
            oscillatorGainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.01);
        }
    });

    // オシレーター波形タイプの切り替え
    oscTypeButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (oscillatorNode && isOscOn) {
                oscTypeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                oscillatorNode.type = button.dataset.type;
            }
        });
    });

    // オシレーター周波数の変更
    oscFrequencySlider.addEventListener('input', (e) => {
        if (oscillatorNode) {
            oscillatorNode.frequency.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
        }
    });

    // オシレーター音量の変更
    oscVolumeSlider.addEventListener('input', (e) => {
        // オシレーターがONの時だけボリューム変更を適用
        if (oscillatorNode && isOscOn) {
            oscillatorGainNode.gain.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
        }
    });

    // ★★★ LFOコントロールのイベントリスナー ★★★
    const lfoRateSlider = document.getElementById('lfo-rate-slider');
    const lfoDepthSlider = document.getElementById('lfo-depth-slider');
    const lfoTypeButtons = document.querySelectorAll('.lfo-type');
    const lfoTargetButtons = document.querySelectorAll('.lfo-target');

    // LFOの速さ(Rate)を変更
    lfoRateSlider.addEventListener('input', (e) => {
        if (lfoNode) {
            lfoNode.frequency.value = parseFloat(e.target.value);
        }
    });

    // LFOの深さ(Depth)を変更
    lfoDepthSlider.addEventListener('input', (e) => {
        if (lfoDepthNode) {
            lfoDepthNode.gain.value = parseFloat(e.target.value);
        }
    });

    // LFOの波形タイプを変更
    lfoTypeButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (lfoNode) {
                lfoTypeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                lfoNode.type = button.dataset.type;
            }
        });
    });

    // LFOのターゲットを変更
    lfoTargetButtons.forEach(button => {
        button.addEventListener('click', () => {
            // メイン電源が入っていない場合は何もしない
            if (!isPowerOn || !lfoDepthNode) return;

            // まず、すべての接続を解除
            lfoDepthNode.disconnect();

            // ターゲットボタンの見た目を更新
            lfoTargetButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            const newTarget = button.dataset.target;
            currentLfoTarget = newTarget;

            // ターゲットに応じて接続先を切り替え
            if (newTarget === 'filterFrequency') {
                lfoDepthNode.connect(filterNode.frequency);
                lfoDepthSlider.max = 5000; // Depthスライダーの最大値を調整
            } else if (newTarget === 'oscFrequency') {
                lfoDepthNode.connect(oscillatorNode.frequency);
                lfoDepthSlider.max = 1000; // Depthスライダーの最大値を調整
            } else {
                // 'none' の場合はDepthを0にしておく
                lfoDepthSlider.value = 0;
                lfoDepthNode.gain.value = 0;
            }
        });
    });

// ★★★ ビジュアライザーON/OFFのイベントリスナー ★★★
    const visualizerToggle = document.getElementById('visualizer-toggle');

    visualizerToggle.addEventListener('click', () => {
        isVisualizerOn = !isVisualizerOn;

        if (isVisualizerOn) {
            visualizerToggle.textContent = 'ON';
            visualizerToggle.classList.add('active');
            // 描画開始はメイン電源がONの時だけ
            if (isPowerOn) {
                drawWaveform();
            }
        } else {
            visualizerToggle.textContent = 'OFF';
            visualizerToggle.classList.remove('active');
            // 描画停止と画面クリアは、電源の状態に関係なく実行する
            cancelAnimationFrame(animationFrameId);
            setTimeout(() => {
                canvasCtx.fillStyle = '#000000';
                canvasCtx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            }, 50);
        }
    });

    // ★★★ 録音機能のロジック ★★★
    const recordButton = document.getElementById('record-button');
    const resultsArea = document.getElementById('recording-results');

    recordButton.addEventListener('click', () => {
        if (!isPowerOn) return; // 電源が入っていないと録音しない

        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    });

    function startRecording() {
        isRecording = true;
        recordedChunks = []; // チャンクをリセット
        resultsArea.innerHTML = ''; // 前回の結果をクリア

        const options = { mimeType: 'audio/webm' };
        try {
            mediaRecorder = new MediaRecorder(recorderDestinationNode.stream, options);
        } catch (e) {
            console.error('Error creating MediaRecorder:', e);
            isRecording = false;
            return;
        }


        mediaRecorder.addEventListener('dataavailable', (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        });

            mediaRecorder.addEventListener('stop', () => {
            // ★ Blobのタイプとファイル名を .wav に変更
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);

            const audio = document.createElement('audio');
            audio.controls = true;
            audio.src = url;
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            const now = new Date();
            const timestamp = `${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
            downloadLink.download = `noise-recording-${timestamp}.webm`;
            downloadLink.innerText = 'Download Recording';

            resultsArea.appendChild(audio);
            resultsArea.appendChild(downloadLink);
        });

        mediaRecorder.start();
        recordButton.textContent = 'STOP RECORDING';
        recordButton.classList.add('recording');
    }

    function stopRecording() {
        if (mediaRecorder) {
            mediaRecorder.stop();
        }
        isRecording = false;
        recordButton.textContent = 'RECORD';
        recordButton.classList.remove('recording');
    }
    

</script>

</body>
</html>
